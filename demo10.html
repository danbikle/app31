<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>app31/demo10</title>

    <script src="/src/convnet_init.js"></script>
    <script src="/src/convnet_util.js"></script>
    <script src="/src/convnet_vol.js"></script>
    <script src="/src/convnet_vol_util.js"></script>
    <script src="/src/convnet_layers_dotproducts.js"></script>
    <script src="/src/convnet_layers_pool.js"></script>
    <script src="/src/convnet_layers_input.js"></script>
    <script src="/src/convnet_layers_loss.js"></script>
    <script src="/src/convnet_layers_nonlinearities.js"></script>
    <script src="/src/convnet_layers_dropout.js"></script>
    <script src="/src/convnet_layers_normalization.js"></script>
    <script src="/src/convnet_net.js"></script>
    <script src="/src/convnet_trainers.js"></script>
    <script src="/src/convnet_magicnet.js"></script>
    <script src="/src/convnet_export.js"></script>
    <script src="/jquery.min.js"></script>
    <script src="/codeshow.js"></script>
    <script src="/d3.v3.min.js"></script>
    <script src="/rickshaw.min.js"></script>

    <link href="/css4demos.css" media="all" rel="stylesheet" />

  </head>
  <body>
    <h1>app31/demo10</h1>
    <script>
    var lagn = function(n,my_a) {
      // This function should return array which lags my_a by n.
      // I should get first n members:
      var front_a = my_a.slice(0,n)
      // I should remove last n members:
      var back_a = my_a.slice(0,my_a.length-n) 
      var lagn_a = front_a.concat(back_a)
      return lagn_a
    }
    var lead1 = function(my_a) {
      // This function should return array which leads my_a by 1.
      return my_a.slice(1).concat(my_a[my_a.length-1])
    }
    var pctlagn = function(n,my_a) {
      var pctlagn_a = []
      var lagn_a    = lagn(n,my_a)
      for (i=0; i<my_a.length;i++) {
        pctlagn_a.push(100.0*(my_a[i]-lagn_a[i])/lagn_a[i])
      }
      return pctlagn_a
    }
    var pctlead1 = function(my_a) {
      var pctlead_a = []
      var lead_a    = lead1(my_a)
      for (i=0; i<my_a.length;i++) {
        pctlead_a.push(100.0*(lead_a[i]-my_a[i])/my_a[i])
      }
      return pctlead_a
    }
    // I should use cpasc_a to store dates,prices,pct-deltas
    var cpasc_a  = []
    d3.csv("/csv/GSPC.csv", function(error, csv_a) {
      if (error) throw error
      // Yahoo gives the data by date descending.
      // I should order it    by date ascending.
      csv_a.reverse()
      // I should use two integers to specify my training data:
      var train_end   = csv_a.length - 252  // 1 yr ago
//      var train_size  = 252*10              // 10 yrs
      var train_size  = 252*2              // 2 yrs
      var train_start = train_end - train_size
      csv_train_a = csv_a.slice(train_start,train_end) 

      // I should get array of closing prices
      var cp_a   = csv_train_a.map(function(row){return +row['Close']})
      var pctlag1 = pctlagn(1,cp_a)
      var pctlag2 = pctlagn(2,cp_a)
      var pctlag4 = pctlagn(4,cp_a)
      var pctlag8 = pctlagn(8,cp_a)
      var fnum    = 4 // Above, I see 4 features now

      var pctlead = pctlead1(cp_a)

      // The MagicNet class performs fully-automatic prediction on your data. 

      // options struct:
      var opts = {} 
      /* what portion of data goes to train, 
      in train/validation fold splits. Here, 0.7 means 70% */
      opts.train_ratio = 0.7 
      // number of folds to evaluate per candidate:
      opts.num_folds = 1 
      // number of candidates to evaluate in parallel:
      opts.num_candidates = 20
      // number of epochs to make through data per fold
      opts.num_epochs = 4
      /* how many nets to average in the end for prediction? 
      likely higher = better but slower: */
      opts.ensemble_size = 4
      var train_data   = []
      var train_length = pctlag1.length
      // I should convert my data into magicnet format which is a collection of Vol objects.
      for(i=0;i<train_size;i++){
        // Vol API for me is usually: Vol(1,1,nmbrOfFeatures,0.0)
//debug
        // var obsv_v = new convnetjs.Vol(1,1,fnum,0.0)
        var obsv_v = new convnetjs.Vol(1,1,1,0.0)
//debug
        obsv_v.w[0] = pctlag1[i]
        train_data.push(obsv_v)
        train_data
      }

      // I should find the median of pctlead in my training data
      train_median     = d3.median(pctlead)
      // I should create an array of 2 labels from train_median
      var train_labels = pctlead.map(function(x){if (x<train_median) return 0; else return 1;})

      var magicNet = new convnetjs.MagicNet(train_data, train_labels, opts)

      // On finish, I should call finishedBatch()
      magicNet.onFinishBatch(finishedBatch)
       
      /* start training MagicNet. 
      Every call trains all candidates in current batch on one example: */
      setInterval(function(){ magicNet.step() })
       
      function finishedBatch() {
        // I should try 2 predictions
        var tstv1 = new convnetjs.Vol(1,1,1)
        tstv1.w[0] = 1.0   // 2stddev up from median
        var prediction1 = magicNet.predict(tstv1)
        var tstv2 = new convnetjs.Vol(1,1,1)
        tstv2.w[0] = -1.0 // 2stddev down from median
        var prediction2 = magicNet.predict(tstv2)

        var mnjson = magicNet.toJSON()
        'finishedBatch'
      }

      'd3.csv done'
    })

    </script>
  </body>
</html>
